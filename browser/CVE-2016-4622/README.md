CVE-2016-4622
===

This vulnerability was discovered by Samuel Gro√ü (saelo).
The purpose of this repo is just to reproduce the exploit for the sake of learning more about JavaScript-Engine exploitation.

*   Original [files](https://github.com/saelo/jscpwn)
*   Original [Write-up](http://www.phrack.org/papers/attacking_javascript_engines.html)

## Vuln

The vuln was in the `arrayProtoFuncSlice` function in the `ArrayPrototype.cpp` file.
You can read the original write-up for a very detailed explanation.
The vuln was fixed in:

```
commit 650552a6ed7cac8aed3f53dd464341728984b82f (HEAD)
Author: msaboff@apple.com <msaboff@apple.com@268f45cc-cd09-0410-ab3c-d52691b4dbfc>
Date:   Tue May 3 21:42:44 2016 +0000

    Crash: Array.prototype.slice() and .splice() can call fastSlice() after an array is truncated
    https://bugs.webkit.org/show_bug.cgi?id=157322

    Reviewed by Filip Pizlo.

    Check to see if the source array has changed length before calling fastSlice().
    If it has, take the slow path.

    * runtime/ArrayPrototype.cpp:
    (JSC::arrayProtoFuncSlice):
    (JSC::arrayProtoFuncSplice):
    * tests/stress/regress-157322.js: New test.


    git-svn-id: http://svn.webkit.org/repository/webkit/trunk@200387 268f45cc-cd09-0410-ab3c-d52691b4dbfc

...

diff --git a/Source/JavaScriptCore/runtime/ArrayPrototype.cpp b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp
index cfdd7fceb7f..08a6ec991af 100644
--- a/Source/JavaScriptCore/runtime/ArrayPrototype.cpp
+++ b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp
@@ -863,7 +863,7 @@ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)
     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
         return JSValue::encode(jsUndefined());
 
-    if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj))) {
+    if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj) && length == getLength(exec, thisObj))) {
         if (JSArray* result = asArray(thisObj)->fastSlice(*exec, begin, end - begin))
             return JSValue::encode(result);
     }
@@ -932,7 +932,7 @@ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)
         return JSValue::encode(jsUndefined());
 
     JSObject* result = nullptr;
-    if (speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj))
+    if (speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj) && length == getLength(exec, thisObj))
         result = asArray(thisObj)->fastSlice(*exec, begin, deleteCount);
 
     if (!result) {
...
```

This makes `320b1fc3f6f47a31b6ccb4578bcea56c32c9e10` the latest commit with the vulnerable code.

One problem I stumbled over while trying to create the exploit is the introduction of [CagedBarrierPtr](https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/CagedBarrierPtr.h).
This resulted in the following change in [abda730189b2e18583bbb629137a96fdb4bd61d8](https://github.com/WebKit/webkit/commit/abda730189b2e18583bbb629137a96fdb4bd61d8#diff-49826b791b68acd214ab94f3ef393b4c):

```
-   void *m_vector;
+   CagedBarrierPtr<Gigacage::Primitive, void> m_vector;
```

This makes the exploit quite harder, since we can't just forge an arbirtrary JSValue-Pointer, but only one in the same heap "cage". The exploit is probably still doable somehow, but for the sake of this exercise I decided to base my exploit on the latest commit without the `CagedBarrierPtr`: [3d9b9ba1f3341456661952128224aa3a3f27ae55](https://github.com/WebKit/webkit/commit/3d9b9ba1f3341456661952128224aa3a3f27ae55).
If you want to learn more about the Heap seperation in WebKit read [this](https://labs.mwrinfosecurity.com/blog/some-brief-notes-on-webkit-heap-hardening/).

## Build Vuln-JSC (Ubuntu 18.04)

I've tried to build `320b1fc3f6f47a31b6ccb4578bcea56c32c9e10` on Ubuntu 18.04, but this code being almost 3 years old by now, didn't compile anymore.
You can check [browser-pwn](https://github.com/m1ghtym0/browser-pwn) for more details on how to build WebKit/JavaScriptCore.
If you're more into fixing old build-chains than me or you're just running an older system, try [try_build.sh](try_build.sh).

Otherwise, I've created a patch, which basically reverts the fix shown above.
Additionally, I had to disable the `verifyPropertiesAreInitialized` call in ObjectInitializationScope.cpp, to reach the vulnerable pattern.

```
$ cp vuln.patch <WebKit-dir>
$ cd <WebKit-dir>
$ git checkout 3d9b9ba1f3341456661952128224aa3a3f27ae55
$ git apply vuln.patch
$ Tools/Scripts/build-jsc --jsc-only --debug 
```

If you don't want to build jsc yourself, I've uploaded the [jsc-binary](https://www.mightym0.de/write-ups/browser/cve-2016-4622/bin/jsc) and [libJavaScriptCore.so.1](https://www.mightym0.de/write-ups/browser/cve-2016-4622/bin/libJavaScriptCore.so.1) binaries.

## Run

```
$ mkdir bin
$ cp <WebKitDir>/WebKitBuild/Debug/bin/jsc bin/
$ cp <WebKitDir>/WebKitBuild/Debug/lib/libJavaScriptCore.so.1.0.0  bin/
$ cp -a <WebKitDir>/WebKitBuild/Debug/lib/libJavaScriptCore.so.1  bin/
$ ./get_dependencies.sh()
$ bin/jsc util.js int64.js pwn.js
```
